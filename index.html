<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SVG Path Shader</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background: #000;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
      }

      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }

      #overlayCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 50;
      }

      .controls {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(10px);
        padding: 20px;
        border-radius: 12px;
        color: white;
        min-width: 300px;
        max-width: 400px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        z-index: 100;
        transition: all 0.3s ease;
      }

      .controls.collapsed {
        padding: 16px;
        min-width: auto;
        overflow: hidden;
      }

      .controls-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        cursor: pointer;
        user-select: none;
      }

      .controls.collapsed .controls-header {
        margin-bottom: 0;
      }

      .toggle-btn {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        padding: 4px 8px;
        cursor: pointer;
        font-size: 12px;
        color: #00ffff;
        transition: all 0.2s ease;
        display: flex;
        flex-direction: column;
        gap: 3px;
        width: 24px;
        height: 24px;
        align-items: center;
        justify-content: center;
      }

      .toggle-btn:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .hamburger-line {
        width: 16px;
        height: 2px;
        background: #00ffff;
        border-radius: 2px;
        transition: all 0.3s ease;
      }

      .controls:not(.collapsed) .hamburger-line {
        display: none;
      }

      .controls h3 {
        transition: opacity 0.3s ease;
        margin: 0;
        font-size: 16px;
        font-weight: 600;
      }

      .controls.collapsed h3 {
        opacity: 0;
        position: absolute;
        pointer-events: none;
      }

      .controls-content {
        max-height: 1000px;
        overflow: scroll;
        padding: 2rem;
        transition: max-height 0.3s ease, opacity 0.3s ease;
        opacity: 1;
      }

      .controls.collapsed .controls-content {
        max-height: 0;
        opacity: 0;
        display: none;
      }

      .control-group {
        margin-bottom: 15px;
      }

      .control-group label {
        display: block;
        margin-bottom: 6px;
        font-size: 12px;
        color: #ccc;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .control-group .value {
        color: #fff;
        font-weight: 600;
        font-size: 13px;
      }

      .control-group input[type="range"] {
        width: 100%;
        height: 5px;
        border-radius: 3px;
        background: rgba(255, 255, 255, 0.2);
        outline: none;
        -webkit-appearance: none;
      }

      .control-group input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #00ffff;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 255, 255, 0.5);
      }

      .control-group input[type="range"]::-moz-range-thumb {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: #00ffff;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 8px rgba(0, 255, 255, 0.5);
      }

      .control-group textarea {
        width: 100%;
        min-height: 80px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        color: white;
        padding: 8px;
        font-size: 11px;
        font-family: monospace;
        resize: vertical;
      }

      .control-group button {
        background: rgba(0, 255, 255, 0.2);
        border: 1px solid rgba(0, 255, 255, 0.4);
        border-radius: 4px;
        color: #00ffff;
        padding: 8px 16px;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s ease;
      }

      .control-group button:hover {
        background: rgba(0, 255, 255, 0.3);
      }

      .section {
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .section:last-of-type {
        border-bottom: none;
      }

      .section-header {
        font-size: 13px;
        font-weight: 600;
        color: #00ffff;
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .info {
        background: rgba(0, 0, 0, 0.6);
        padding: 2px 16px;
        border-radius: 8px;
        color: #ccc;
        font-size: 11px;
        margin-top: 15px;
      }

      .info strong,
      a {
        color: #fff;
        text-decoration: none;
      }

      .preset-buttons {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }

      .preset-buttons button {
        flex: 1;
        min-width: 70px;
      }
    </style>
  </head>
  <body>
    <canvas id="glCanvas"></canvas>
    <canvas id="overlayCanvas"></canvas>

    <div class="controls" id="controls">
      <div class="controls-header" id="controlsHeader">
        <h3>SVG Path Shader</h3>
        <button class="toggle-btn" id="toggleBtn">
          <span class="hamburger-line"></span>
          <span class="hamburger-line"></span>
          <span class="hamburger-line"></span>
        </button>
      </div>

      <div class="controls-content">
        <!-- Animation Section -->
        <div class="section">
          <div class="section-header">Animation</div>

          <div class="control-group">
            <label>
              <span>Speed</span>
              <span class="value" id="speedValue">1.0</span>
            </label>
            <input
              type="range"
              id="speed"
              min="0.1"
              max="3"
              step="0.1"
              value="1.0"
            />
          </div>

          <div class="control-group">
            <label>
              <span>Scale</span>
              <span class="value" id="scaleValue">0.1</span>
            </label>
            <input
              type="range"
              id="scale"
              min="0.01"
              max="0.5"
              step="0.01"
              value="0.1"
            />
          </div>

          <div class="control-group">
            <label>
              <span>Reverse Direction</span>
              <input
                type="checkbox"
                id="reverse"
                style="width: auto; height: auto; cursor: pointer"
              />
            </label>
          </div>
        </div>

        <!-- Visual Effects Section -->
        <div class="section">
          <div class="section-header">Visual Effects</div>

          <div class="control-group">
            <label>
              <span>Intensity</span>
              <span class="value" id="intensityValue">1.0</span>
            </label>
            <input
              type="range"
              id="intensity"
              min="0.1"
              max="3"
              step="0.1"
              value="1.0"
            />
          </div>

          <div class="control-group">
            <label>
              <span>Fade Effect</span>
              <span class="value" id="fadeValue">0.5</span>
            </label>
            <input
              type="range"
              id="fade"
              min="0"
              max="1"
              step="0.01"
              value="0.5"
            />
          </div>

          <div class="control-group">
            <label>
              <span>Glow Spread</span>
              <span class="value" id="glowSpreadValue">1.0</span>
            </label>
            <input
              type="range"
              id="glowSpread"
              min="0.1"
              max="5"
              step="0.1"
              value="1.0"
            />
          </div>

          <div class="control-group">
            <label>
              <span>Glow Falloff</span>
              <span class="value" id="glowFalloffValue">1.0</span>
            </label>
            <input
              type="range"
              id="glowFalloff"
              min="0.5"
              max="3"
              step="0.1"
              value="1.0"
            />
          </div>

          <div class="control-group">
            <label>
              <span>Circle Radius</span>
              <span class="value" id="circleRadiusValue">0.0</span>
            </label>
            <input
              type="range"
              id="circleRadius"
              min="0"
              max="35"
              step="0.1"
              value="0"
            />
          </div>

          <div class="control-group">
            <label>
              <span>Number of Circles</span>
              <span class="value" id="numCirclesValue">100</span>
            </label>
            <input
              type="range"
              id="numCircles"
              min="20"
              max="200"
              step="10"
              value="100"
            />
          </div>
        </div>

        <!-- Color Section -->
        <div class="section">
          <div class="section-header">Color</div>

          <div class="control-group">
            <label>
              <span>Hue Shift</span>
              <span class="value" id="hueShiftValue">0</span>
            </label>
            <input
              type="range"
              id="hueShift"
              min="0"
              max="360"
              step="1"
              value="0"
            />
          </div>

          <div class="control-group">
            <label>
              <span>Saturation</span>
              <span class="value" id="saturationValue">1.0</span>
            </label>
            <input
              type="range"
              id="saturation"
              min="0"
              max="2"
              step="0.1"
              value="1.0"
            />
          </div>

          <div class="control-group">
            <label>
              <span>Brightness</span>
              <span class="value" id="brightnessValue">1.0</span>
            </label>
            <input
              type="range"
              id="brightness"
              min="0.1"
              max="2"
              step="0.1"
              value="1.0"
            />
          </div>
        </div>

        <!-- Layout Section -->
        <div class="section">
          <div class="section-header">Layout</div>

          <div class="control-group">
            <label>
              <span>Grid Rows</span>
              <span class="value" id="gridRowsValue">1</span>
            </label>
            <input
              type="range"
              id="gridRows"
              min="1"
              max="4"
              step="1"
              value="1"
            />
          </div>

          <div class="control-group">
            <label>
              <span>Grid Columns</span>
              <span class="value" id="gridColsValue">1</span>
            </label>
            <input
              type="range"
              id="gridCols"
              min="1"
              max="4"
              step="1"
              value="1"
            />
          </div>
        </div>

        <!-- Path Section -->
        <div class="section">
          <div class="section-header">Path</div>

          <div class="control-group">
            <label>
              <span>Path Influence</span>
              <span class="value" id="pathInfluenceValue">1.0</span>
            </label>
            <input
              type="range"
              id="pathInfluence"
              min="0"
              max="1"
              step="0.1"
              value="1.0"
            />
          </div>

          <div class="control-group">
            <label>
              <span>Path Scale</span>
              <span class="value" id="pathScaleValue">1.0</span>
            </label>
            <input
              type="range"
              id="pathScale"
              min="0.1"
              max="3"
              step="0.1"
              value="1.0"
            />
          </div>

          <div class="control-group">
            <label>
              <span>Number of Points</span>
              <span class="value" id="numPointsValue">64</span>
            </label>
            <input
              type="range"
              id="numPoints"
              min="16"
              max="128"
              step="16"
              value="64"
            />
          </div>

          <div class="control-group">
            <label>
              <span>Flip X</span>
              <input
                type="checkbox"
                id="flipX"
                style="width: auto; height: auto; cursor: pointer"
              />
            </label>
          </div>

          <div class="control-group">
            <label>
              <span>Flip Y</span>
              <input
                type="checkbox"
                id="flipY"
                checked
                style="width: auto; height: auto; cursor: pointer"
              />
            </label>
          </div>

          <div class="control-group">
            <label>
              <span>Show Path</span>
              <input
                type="checkbox"
                id="showPath"
                style="width: auto; height: auto; cursor: pointer"
              />
            </label>
          </div>

          <div class="control-group">
            <label style="display: block; margin-bottom: 8px"
              >Preset Paths:</label
            >
            <div class="preset-buttons">
              <button onclick="loadPreset('circle')">Circle</button>
              <button onclick="loadPreset('heart')">Heart</button>
              <button onclick="loadPreset('star')">Star</button>
              <button onclick="loadPreset('infinity')">Infinity</button>
              <button onclick="loadPreset('bonjour')">Bonjour</button>
            </div>
          </div>

          <div class="control-group">
            <label style="display: block; margin-bottom: 8px"
              >Custom SVG Path:</label
            >
            <textarea
              id="svgPath"
              placeholder="Paste SVG path data (d attribute)..."
            ></textarea>
            <button
              onclick="loadCustomPath()"
              style="margin-top: 8px; width: 100%"
            >
              Load Path
            </button>
          </div>
        </div>

        <div class="info">
          <strong>SVG LED Shader</strong><br />
          Choose a preset or paste your own SVG path data<br />
          Path Influence blends between original and SVG paths
          <br />
          <br />
          Original concept by @XorDev on Twitter/X
        </div>

        <div style="padding-top: 1rem">
          <a href="https://github.com/npanium/SVG-LED-Shader/">Github</a>
        </div>
      </div>
    </div>

    <script>
      const canvas = document.getElementById("glCanvas");
      const gl = canvas.getContext("webgl", {
        alpha: false,
        antialias: true,
        preserveDrawingBuffer: false,
      });

      if (!gl) {
        document.body.innerHTML =
          '<div style="color: white; padding: 40px; text-align: center;"><h2>WebGL not supported</h2><p>Your browser does not support WebGL</p></div>';
        throw new Error("WebGL not supported");
      }

      // Parameters
      let speed = 1.0;
      let intensity = 1.0;
      let scale = 0.1;
      let fade = 0.5;
      let glowSpread = 1.0;
      let glowFalloff = 1.0;
      let hueShift = 0;
      let saturation = 1.0;
      let brightness = 1.0;
      let pathInfluence = 1.0;
      let pathScale = 1.0;
      let flipX = false;
      let flipY = true;
      let reverse = false;
      let circleRadius = 0.0;
      let showPath = false;
      let numPathPoints = 64;
      let numCircles = 100;
      let gridRows = 1;
      let gridCols = 1;
      let currentPreset = "bonjour";

      // Path points (sampled from SVG)
      let pathPoints = [];
      const MAX_PATH_POINTS = 128;

      // Overlay canvas for visualizing path
      const overlayCanvas = document.getElementById("overlayCanvas");
      const overlayCtx = overlayCanvas.getContext("2d");

      // SVG Path presets
      const presets = {
        circle: "M 0.5 0.2 A 0.3 0.3 0 1 1 0.5 0.19999 Z",
        heart:
          "M 0.5 0.3 C 0.5 0.25, 0.45 0.2, 0.4 0.2 C 0.3 0.2, 0.25 0.3, 0.25 0.4 C 0.25 0.55, 0.35 0.65, 0.5 0.8 C 0.65 0.65, 0.75 0.55, 0.75 0.4 C 0.75 0.3, 0.7 0.2, 0.6 0.2 C 0.55 0.2, 0.5 0.25, 0.5 0.3 Z",
        star: "M 0.5 0.2 L 0.55 0.4 L 0.75 0.4 L 0.6 0.52 L 0.65 0.72 L 0.5 0.6 L 0.35 0.72 L 0.4 0.52 L 0.25 0.4 L 0.45 0.4 Z",
        infinity:
          "M346.8 345.9c5.5-5.7 12.1-12.6 20.3-12.6 7.2 0 12.4 5.4 12.4 12.9 0 6.9-5.6 12.9-12.9 12.9-8.5 0-14.1-7.2-19.8-12.5l-.8-.8c-5.7-5.3-11.2-12.5-19.7-12.5-7.3 0-12.9 6-12.9 12.9 0 7.5 5.3 12.9 12.4 12.9 8.3 0 14.8-6.9 20.3-12.6C346.3 346.5 346.8 346 346.8 345.9z",
        bonjour:
          "M-458.2 210.55c81.4 -28.4 136.8 -85.4 194.2 -205.8c18.6 -44.4 43.8 -120 -10.8 -129.2c-65.8 11.8 -79.4 127 -90.4 188.2c-46.6 339.8 272.6 136 96.8 -3.2c74 76.8 127.6 63 198.4 12.8c53 -38.8 120 -9.8 118.8 69c7.6 122.4 -165.2 156 -158.4 18.8c3.6 -60.6 39.2 -104.8 86.4 -104.8c76.4 5.4 146.8 113.8 205.4 2.4c-9.4 63 -17.2 125 -27.2 188c4.6 -84.8 48.8 -200.2 111.6 -192c34.8 0 52.6 23.8 49.6 57.6c-5 46.6 -39.8 135.4 35 137c66.8 3.6 121 -109.2 126.8 -191c-24.2 84 2.4 333 -94.8 345c-23.4 0 -40.2 -15 -40.2 -38.8c6.8 -90.8 223.8 -78.4 261 -218c21.6 -109.4 160 -128.4 164 -4.2c0 62 -40.4 108.8 -91.2 109.2c-111 3 -78.6 -204.2 17.2 -195c87.2 9.2 151 116.6 214 2.8c-9.6 69 -62 180 35 188.2c74 7 98.8 -112 111.8 -188c-12.4 68.6 -22.6 109.6 -22.6 132.4c0 34.2 13.4 57.6 50 57.6c59 0 109.2 -83.6 134.6 -197l-4 16.8c187.8 -4.8 -2.8 158.6 116.6 180.6c38.4 0 64.8 -25.6 75.2 -51.4",
      };

      let currentProgram = null;
      let vertexShader = null;
      let buffer = null;
      let positionLocation = null;

      function parseSVGPath(pathData) {
        const svg = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "svg"
        );
        const path = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        path.setAttribute("d", pathData);
        svg.appendChild(path);
        document.body.appendChild(svg);

        const totalLength = path.getTotalLength();
        const points = [];

        for (let i = 0; i < numPathPoints; i++) {
          const t = (i / numPathPoints) * totalLength;
          const point = path.getPointAtLength(t);
          points.push({ x: point.x, y: point.y });
        }

        document.body.removeChild(svg);
        return points;
      }

      function normalizePath(points) {
        let minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;
        points.forEach((p) => {
          minX = Math.min(minX, p.x);
          minY = Math.min(minY, p.y);
          maxX = Math.max(maxX, p.x);
          maxY = Math.max(maxY, p.y);
        });

        const width = maxX - minX;
        const height = maxY - minY;
        const scale = Math.max(width, height);

        // Center the shape while preserving aspect ratio
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;

        return points.map((p) => ({
          x: ((p.x - centerX) / scale) * 0.4 + 0.5,
          y: ((p.y - centerY) / scale) * 0.4 + 0.5,
        }));
      }

      function loadPreset(name) {
        currentPreset = name;
        const pathData = presets[name];
        const points = parseSVGPath(pathData);
        pathPoints = normalizePath(points);
        rebuildShader();
        drawPath();
      }

      function loadCustomPath() {
        const pathData = document.getElementById("svgPath").value.trim();
        if (!pathData) return;

        try {
          currentPreset = null;
          const points = parseSVGPath(pathData);
          pathPoints = normalizePath(points);
          rebuildShader();
          drawPath();
        } catch (e) {
          alert("Invalid SVG path data: " + e.message);
        }
      }

      function drawPath() {
        overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

        if (!showPath || pathPoints.length < 2) return;

        overlayCtx.strokeStyle = "rgba(0, 255, 255, 0.5)";
        overlayCtx.lineWidth = 2;
        overlayCtx.beginPath();

        pathPoints.forEach((point, i) => {
          const x =
            point.x * overlayCanvas.height +
            (overlayCanvas.width - overlayCanvas.height) / 2;
          const y = point.y * overlayCanvas.height;

          if (i === 0) {
            overlayCtx.moveTo(x, y);
          } else {
            overlayCtx.lineTo(x, y);
          }
        });

        overlayCtx.closePath();
        overlayCtx.stroke();

        pathPoints.forEach((point, i) => {
          if (i % 4 === 0) {
            const x =
              point.x * overlayCanvas.height +
              (overlayCanvas.width - overlayCanvas.height) / 2;
            const y = point.y * overlayCanvas.height;

            overlayCtx.fillStyle = "rgba(0, 255, 255, 0.6)";
            overlayCtx.beginPath();
            overlayCtx.arc(x, y, 3, 0, Math.PI * 2);
            overlayCtx.fill();
          }
        });
      }

      function resizeOverlay() {
        overlayCanvas.width = window.innerWidth;
        overlayCanvas.height = window.innerHeight;
        drawPath();
      }

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
        resizeOverlay();
      }
      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      const vertexShaderSource = `
        attribute vec2 position;
        void main() {
          gl_Position = vec4(position, 0.0, 1.0);
        }
      `;

      function compileShader(source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          const info = gl.getShaderInfoLog(shader);
          console.error("Shader compile error:", info);
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      function rebuildShader() {
        const fragmentShaderSource = `
          precision highp float;
          uniform vec2 iResolution;
          uniform float iTime;
          uniform float uSpeed;
          uniform float uIntensity;
          uniform float uScale;
          uniform float uFade;
          uniform float uGlowSpread;
          uniform float uGlowFalloff;
          uniform float uHueShift;
          uniform float uSaturation;
          uniform float uBrightness;
          uniform float uPathInfluence;
          uniform float uPathScale;
          uniform float uFlipX;
          uniform float uFlipY;
          uniform float uCircleRadius;
          uniform float uReverse;
          uniform float uNumCircles;
          uniform float uGridRows;
          uniform float uGridCols;
          uniform vec2 uPathPoints[${numPathPoints}];
          uniform int uNumPathPoints;
          
          // RGB to HSV conversion
          vec3 rgb2hsv(vec3 c) {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
          }
          
          // HSV to RGB conversion
          vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
          }
          
          int imin(int a, int b) {
            return a < b ? a : b;
          }
          
          vec2 getPathPoint(int index) {
            for(int i = 0; i < ${numPathPoints}; i++) {
              if(i == index) return uPathPoints[i];
            }
            return vec2(0.5);
          }
          
          vec2 getPathPosition(float t) {
            if (uNumPathPoints < 2) return vec2(0.5);
            
            t = mod(t, 1.0);
            float segmentFloat = t * float(uNumPathPoints - 1);
            int segment = int(floor(segmentFloat));
            float localT = segmentFloat - float(segment);
            
            vec2 p1 = getPathPoint(segment);
            vec2 p2 = getPathPoint(imin(segment + 1, uNumPathPoints - 1));
            
            vec2 pos = mix(p1, p2, localT);
            
            pos = (pos - 0.5) * uPathScale + 0.5;
            if (uFlipX > 0.5) pos.x = 1.0 - pos.x;
            if (uFlipY > 0.5) pos.y = 1.0 - pos.y;
            
            return pos;
          }
          
          void main() {
            vec2 FC = gl_FragCoord.xy;
            vec2 r = iResolution;
            float t = iTime * uSpeed;
            vec4 o = vec4(0.0);
            
            // Calculate grid cell size
            vec2 cellSize = r / vec2(uGridCols, uGridRows);
            
            // Determine which grid cell we're in
            vec2 gridPos = floor(FC / cellSize);
            
            // Local position within the cell
            // vec2 localFC = mod(FC, cellSize);
            vec2 localFC = FC;
            
            // Use fixed step size, control visibility based on numCircles
            for(float i = 0.0; i < 1.0; i += 0.005) {
              // Calculate which circle index this is out of the total
              float circleIndex = i * 200.0; // Max 200 circles (step 0.005)
              
              // Skip if beyond our desired number of circles
              if (circleIndex >= uNumCircles) continue;
              
              // Normalize i to 0-1 range based on actual number of circles
              float normalizedI = circleIndex / uNumCircles;
              
              // Add grid offset to time for variety
              float gridOffset = (gridPos.x + gridPos.y * uGridCols) * 0.3;
              float localT = t + gridOffset;
              
              // Original triangular wave pattern (scaled to cell)
              vec2 originalPos = (cos((normalizedI + ceil(localT / uScale) * uScale) / vec2(0.21, 0.11)) * 0.4 + 0.5) * cellSize;
              
              // SVG path position (scaled to cell)
              // FIXED: OFF = left-to-right (1.0), ON = right-to-left (-1.0)
              float direction = uReverse > 0.5 ? -1.0 : 1.0;
              float pathT = mod((normalizedI + ceil(localT / uScale) * uScale * direction * 0.1), 1.0);
              vec2 pathPoint = getPathPosition(pathT);
              vec2 pathPos = vec2(pathPoint.x * cellSize.y + (cellSize.x - cellSize.y) * 0.5, pathPoint.y * cellSize.y);

              // Blend between original and SVG path
              vec2 circleCenter = mix(originalPos, pathPos, uPathInfluence);
              
              // Distance from pixel to circle center (using local position)
              // float dist = length(localFC - circleCenter) - cellSize.y * 0.01 * uCircleRadius;
              vec2 globalCircleCenter = circleCenter + gridPos * cellSize; // Convert to global position
float dist = length(FC - globalCircleCenter) - cellSize.y * 0.01 * uCircleRadius;
              
              // Fade effect: blend between i*i (concentrated) and constant (uniform)
              float fadeContrib = mix(normalizedI * normalizedI, 0.01, uFade);
              
              // Apply glow spread and falloff power for tighter control
              float contribution = fadeContrib / pow(abs(dist) * uGlowSpread + 1.0, uGlowFalloff);
              
              // Gradual fade in/out based on time progression
              // Calculate how far along the wave we are
              float waveProgress = ceil(localT / uScale) * uNumCircles;
              
              // FIXED fade direction: OFF = appear left-to-right, ON = appear right-to-left
              // We FLIP the logic here so left (low index) appears first when reverse is OFF
              float fadeDistance = uReverse > 0.5 ? 
                (circleIndex - waveProgress) : 
                (uNumCircles - circleIndex - waveProgress);
              
              // Smooth fade: negative = fully visible, 0-5 = fading in, >5 = invisible
              float opacity = smoothstep(5.0, 0.0, fadeDistance);
              

              // Color based on position and time
              vec4 color = (cos((normalizedI + localT) / 0.1 + vec4(0.0, 7.0, 8.0, 0.0)) + 1.0);
              
              // o += contribution * color * uIntensity * opacity;
              o += contribution * color * uIntensity * opacity * normalizedI * normalizedI;
            }
            
            // Apply HSB adjustments
            vec3 hsv = rgb2hsv(o.rgb);
            hsv.x = mod(hsv.x + uHueShift / 360.0, 1.0);
            hsv.y *= uSaturation;
            hsv.z *= uBrightness;
            o.rgb = hsv2rgb(hsv);
            
            gl_FragColor = o;
          }
        `;

        // Clean up old program
        if (currentProgram) {
          gl.deleteProgram(currentProgram);
        }

        // Compile shaders
        if (!vertexShader) {
          vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        }
        const fragmentShader = compileShader(
          fragmentShaderSource,
          gl.FRAGMENT_SHADER
        );

        if (!vertexShader || !fragmentShader) {
          throw new Error("Shader compilation failed");
        }

        currentProgram = gl.createProgram();
        gl.attachShader(currentProgram, vertexShader);
        gl.attachShader(currentProgram, fragmentShader);
        gl.linkProgram(currentProgram);

        if (!gl.getProgramParameter(currentProgram, gl.LINK_STATUS)) {
          const info = gl.getProgramInfoLog(currentProgram);
          console.error("Program link error:", info);
          throw new Error("Program linking failed");
        }

        gl.useProgram(currentProgram);

        // Set up geometry
        if (!buffer) {
          const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
          buffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        }

        positionLocation = gl.getAttribLocation(currentProgram, "position");
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
      }

      // Initial shader build
      rebuildShader();

      // Animation
      let startTime = Date.now();

      function render() {
        const currentTime = (Date.now() - startTime) / 1000.0;

        const iResolutionLocation = gl.getUniformLocation(
          currentProgram,
          "iResolution"
        );
        const iTimeLocation = gl.getUniformLocation(currentProgram, "iTime");
        const speedLocation = gl.getUniformLocation(currentProgram, "uSpeed");
        const intensityLocation = gl.getUniformLocation(
          currentProgram,
          "uIntensity"
        );
        const scaleLocation = gl.getUniformLocation(currentProgram, "uScale");
        const fadeLocation = gl.getUniformLocation(currentProgram, "uFade");
        const glowSpreadLocation = gl.getUniformLocation(
          currentProgram,
          "uGlowSpread"
        );
        const glowFalloffLocation = gl.getUniformLocation(
          currentProgram,
          "uGlowFalloff"
        );
        const hueShiftLocation = gl.getUniformLocation(
          currentProgram,
          "uHueShift"
        );
        const saturationLocation = gl.getUniformLocation(
          currentProgram,
          "uSaturation"
        );
        const brightnessLocation = gl.getUniformLocation(
          currentProgram,
          "uBrightness"
        );
        const pathInfluenceLocation = gl.getUniformLocation(
          currentProgram,
          "uPathInfluence"
        );
        const pathScaleLocation = gl.getUniformLocation(
          currentProgram,
          "uPathScale"
        );
        const flipXLocation = gl.getUniformLocation(currentProgram, "uFlipX");
        const flipYLocation = gl.getUniformLocation(currentProgram, "uFlipY");
        const reverseLocation = gl.getUniformLocation(
          currentProgram,
          "uReverse"
        );
        const circleRadiusLocation = gl.getUniformLocation(
          currentProgram,
          "uCircleRadius"
        );
        const numCirclesLocation = gl.getUniformLocation(
          currentProgram,
          "uNumCircles"
        );
        const gridRowsLocation = gl.getUniformLocation(
          currentProgram,
          "uGridRows"
        );
        const gridColsLocation = gl.getUniformLocation(
          currentProgram,
          "uGridCols"
        );
        const pathPointsLocation = gl.getUniformLocation(
          currentProgram,
          "uPathPoints"
        );
        const numPathPointsLocation = gl.getUniformLocation(
          currentProgram,
          "uNumPathPoints"
        );

        gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
        gl.uniform1f(iTimeLocation, currentTime);
        gl.uniform1f(speedLocation, speed);
        gl.uniform1f(intensityLocation, intensity);
        gl.uniform1f(scaleLocation, scale);
        gl.uniform1f(fadeLocation, fade);
        gl.uniform1f(glowSpreadLocation, glowSpread);
        gl.uniform1f(glowFalloffLocation, glowFalloff);
        gl.uniform1f(hueShiftLocation, hueShift);
        gl.uniform1f(saturationLocation, saturation);
        gl.uniform1f(brightnessLocation, brightness);
        gl.uniform1f(pathInfluenceLocation, pathInfluence);
        gl.uniform1f(pathScaleLocation, pathScale);
        gl.uniform1f(flipXLocation, flipX ? 1.0 : 0.0);
        gl.uniform1f(flipYLocation, flipY ? 1.0 : 0.0);
        gl.uniform1f(reverseLocation, reverse ? 1.0 : 0.0);
        gl.uniform1f(circleRadiusLocation, circleRadius);
        gl.uniform1f(numCirclesLocation, numCircles);
        gl.uniform1f(gridRowsLocation, gridRows);
        gl.uniform1f(gridColsLocation, gridCols);
        gl.uniform1i(numPathPointsLocation, pathPoints.length);

        const pointsArray = new Float32Array(numPathPoints * 2);
        for (let i = 0; i < Math.min(numPathPoints, pathPoints.length); i++) {
          pointsArray[i * 2] = pathPoints[i].x;
          pointsArray[i * 2 + 1] = pathPoints[i].y;
        }
        gl.uniform2fv(pathPointsLocation, pointsArray);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        requestAnimationFrame(render);
      }

      render();

      // Controls
      const controlsEl = document.getElementById("controls");
      const controlsHeader = document.getElementById("controlsHeader");

      controlsHeader.addEventListener("click", () => {
        controlsEl.classList.toggle("collapsed");
      });

      document.getElementById("speed").addEventListener("input", (e) => {
        speed = parseFloat(e.target.value);
        document.getElementById("speedValue").textContent = speed.toFixed(1);
      });

      document.getElementById("intensity").addEventListener("input", (e) => {
        intensity = parseFloat(e.target.value);
        document.getElementById("intensityValue").textContent =
          intensity.toFixed(1);
      });

      document.getElementById("scale").addEventListener("input", (e) => {
        scale = parseFloat(e.target.value);
        document.getElementById("scaleValue").textContent = scale.toFixed(2);
      });

      document.getElementById("fade").addEventListener("input", (e) => {
        fade = parseFloat(e.target.value);
        document.getElementById("fadeValue").textContent = fade.toFixed(2);
      });

      document.getElementById("glowSpread").addEventListener("input", (e) => {
        glowSpread = parseFloat(e.target.value);
        document.getElementById("glowSpreadValue").textContent =
          glowSpread.toFixed(1);
      });

      document.getElementById("glowFalloff").addEventListener("input", (e) => {
        glowFalloff = parseFloat(e.target.value);
        document.getElementById("glowFalloffValue").textContent =
          glowFalloff.toFixed(1);
      });

      document.getElementById("hueShift").addEventListener("input", (e) => {
        hueShift = parseFloat(e.target.value);
        document.getElementById("hueShiftValue").textContent =
          hueShift.toFixed(0);
      });

      document.getElementById("saturation").addEventListener("input", (e) => {
        saturation = parseFloat(e.target.value);
        document.getElementById("saturationValue").textContent =
          saturation.toFixed(1);
      });

      document.getElementById("brightness").addEventListener("input", (e) => {
        brightness = parseFloat(e.target.value);
        document.getElementById("brightnessValue").textContent =
          brightness.toFixed(1);
      });

      document
        .getElementById("pathInfluence")
        .addEventListener("input", (e) => {
          pathInfluence = parseFloat(e.target.value);
          document.getElementById("pathInfluenceValue").textContent =
            pathInfluence.toFixed(1);
        });

      document.getElementById("pathScale").addEventListener("input", (e) => {
        pathScale = parseFloat(e.target.value);
        document.getElementById("pathScaleValue").textContent =
          pathScale.toFixed(1);
      });

      document.getElementById("numPoints").addEventListener("input", (e) => {
        numPathPoints = parseInt(e.target.value);
        document.getElementById("numPointsValue").textContent = numPathPoints;
        // Reload current path with new point count
        if (currentPreset) {
          loadPreset(currentPreset);
        } else if (document.getElementById("svgPath").value.trim()) {
          loadCustomPath();
        }
      });

      document.getElementById("numCircles").addEventListener("input", (e) => {
        numCircles = parseInt(e.target.value);
        document.getElementById("numCirclesValue").textContent = numCircles;
      });

      document.getElementById("gridRows").addEventListener("input", (e) => {
        gridRows = parseInt(e.target.value);
        document.getElementById("gridRowsValue").textContent = gridRows;
      });

      document.getElementById("gridCols").addEventListener("input", (e) => {
        gridCols = parseInt(e.target.value);
        document.getElementById("gridColsValue").textContent = gridCols;
      });

      document.getElementById("flipX").addEventListener("change", (e) => {
        flipX = e.target.checked;
      });

      document.getElementById("flipY").addEventListener("change", (e) => {
        flipY = e.target.checked;
      });

      document.getElementById("reverse").addEventListener("change", (e) => {
        reverse = e.target.checked;
      });

      document.getElementById("circleRadius").addEventListener("input", (e) => {
        circleRadius = parseFloat(e.target.value);
        document.getElementById("circleRadiusValue").textContent =
          circleRadius.toFixed(1);
      });

      document.getElementById("showPath").addEventListener("change", (e) => {
        showPath = e.target.checked;
        drawPath();
      });

      // Load default preset
      loadPreset("bonjour");
    </script>
  </body>
</html>
